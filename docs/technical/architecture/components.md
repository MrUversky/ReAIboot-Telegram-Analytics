# Архитектура системы

## Обзор

Этот документ описывает основные компоненты и архитектуру системы ReAIboot.

## Классы и компоненты

### PromptUpdate

**Файл:** `src/api_main.py`

**Описание:** No additional info

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### ChannelBaselineAnalyzer

**Файл:** `src/app/channel_baseline_analyzer.py`

**Описание:** Docstring:     """Анализатор базовых метрик каналов."""      def __init__(self, supabase_manager: SupabaseManager):         """...; Has __init__ method

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### SupabaseClient

**Файл:** `src/app/supabase_client.py`

**Описание:** Docstring:     """Клиент для работы с Supabase."""      def __init__(self):         self.client: Optional[Any] = None         self._initialize_client()      def _initialize_client(self):         """Инициализация...; Has __init__ method

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### ParsingRequest

**Файл:** `src/api_main.py`

**Описание:** No additional info

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### BulkParsingRequest

**Файл:** `src/api_main.py`

**Описание:** No additional info

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### TelegramAnalyzer

**Файл:** `src/app/telegram_client.py`

**Описание:** Docstring:     """Класс для анализа Telegram-каналов с использованием Telethon."""      def __init__(self, session_name: Optional[str] = None):         """...; Has __init__ method

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### ParsingResponse

**Файл:** `src/api_main.py`

**Описание:** No additional info

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### ChannelManagementRequest

**Файл:** `src/api_main.py`

**Описание:** No additional info

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### Settings

**Файл:** `src/app/settings.py`

**Описание:** Docstring:     """Класс для управления всеми настройками приложения."""      def __init__(self):         # Telegram настройки         self.telegram_api_id = int(os.getenv("TELEGRAM_API_ID", "0"))         self.te...; Has __init__ method

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### LLMPriceManager

**Файл:** `src/app/settings.py`

**Описание:** Docstring:     """Продвинутый менеджер для получения актуальных цен на LLM API."""      # Дефолтные цены (последнее известное значение)     DEFAULT_PRICES = {         "gpt-4o": {             "input": 2.50,  # $2...

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### RubricSelectorProcessor

**Файл:** `src/app/llm/rubric_selector_processor.py`

**Описание:** Docstring:     """Процессор для выбора подходящих рубрик и форматов."""      def __init__(self):         """Инициализирует процессор выбора рубрик."""...; Has __init__ method

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### ProcessingResult

**Файл:** `src/app/llm/base_processor.py`

**Описание:** Docstring:     """Результат обработки поста."""     success: bool     data: Optional[Dict[str, Any]] = None     error: Optional[str] = None     tokens_used: int = 0     processing_time: float = 0.0     raw_respo...; Has __init__ method

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### BaseLLMProcessor

**Файл:** `src/app/llm/base_processor.py`

**Описание:** Docstring:     """Базовый класс для всех LLM процессоров."""      def __init__(self, model_name: str, api_key: Optional[str] = None):         """...; Has __init__ method

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### ProcessingStage

### ProcessingStage

**Файл:** `src/app/llm/orchestrator.py`

**Описание:** Docstring:     """Результат одного этапа обработки."""     stage_name: str     success: bool     data: Optional[Dict[str, Any]] = None     error: Optional[str] = None     tokens_used: int = 0     processing_time...

# Описание компонента `ProcessingStage`

## 1. Назначение компонента
Компонент `ProcessingStage` представляет собой структуру данных, которая хранит информацию о результате одного этапа обработки в системе ReAIboot. Он используется для отслеживания статуса, данных и времени обработки на каждом из этапов, таких как фильтрация, анализ и генерация.

## 2. Основные методы/функции
Компонент `ProcessingStage` является простым классом данных (dataclass) и не содержит методов, кроме автоматически сгенерированных для работы с полями. Основные поля класса включают:
- `stage_name`: название этапа обработки.
- `success`: булевый флаг, указывающий на успешность этапа.
- `data`: необязательный словарь, содержащий данные, полученные на этапе.
- `error`: необязательная строка, содержащая информацию об ошибке, если таковая произошла.
- `tokens_used`: количество токенов, использованных на этапе.
- `processing_time`: время, затраченное на обработку этапа.

## 3. Зависимости и связи с другими компонентами
`ProcessingStage` используется в классе `OrchestratorResult`, который представляет собой результат полной обработки поста. `OrchestratorResult` включает список объектов `ProcessingStage`, что позволяет агрегировать результаты всех этапов обработки. Также класс `ProcessingStage` тесно связан с другими процессорами, такими как `FilterProcessor`, `AnalysisProcessor`, `RubricSelectorProcessor` и `GeneratorProcessor`, которые выполняют соответствующие этапы обработки.

## 4. Особенности реализации
Класс `ProcessingStage` реализован как dataclass, что упрощает создание экземпляров и управление их состоянием. Он предоставляет удобный способ хранения и передачи информации о каждом этапе обработки, что делает его важным элементом в архитектуре многоэтапной обработки данных в системе ReAIboot.


## 1. Назначение компонента
Компонент `ProcessingStage` представляет собой структуру данных, которая хранит результаты одного этапа обработки в системе ReAIboot. Он используется для отслеживания информации о каждом этапе обработки данных, включая успешность выполнения, использованные токены и время обработки.

## 2. Основные методы/функции
Компонент `ProcessingStage` не содержит методов, так как реализован как класс данных (dataclass). Однако, его атрибуты позволяют хранить следующую информацию:
- `stage_name`: название этапа обработки.
- `success`: булевый флаг, указывающий на успешность выполнения этапа.
- `data`: опциональный словарь, содержащий данные, полученные на данном этапе.
- `error`: опциональная строка, содержащая сообщение об ошибке, если этап не был успешным.
- `tokens_used`: количество токенов, использованных на данном этапе.
- `processing_time`: время, затраченное на выполнение этапа.

## 3. Зависимости и связи с другими компонентами
`ProcessingStage` является частью класса `LLMOrchestrator`, который управляет многоэтапной обработкой данных. Он используется в классе `OrchestratorResult`, который агрегирует результаты всех этапов обработки. Таким образом, `ProcessingStage` служит для представления промежуточных результатов, которые затем собираются в итоговый результат обработки.

## 4. Особенности реализации
- Класс реализован с использованием декоратора `@dataclass`, что упрощает создание и управление экземплярами класса.
- Все атрибуты имеют типы данных, что способствует лучшей читаемости и поддерживаемости кода.
- Опциональные атрибуты позволяют гибко обрабатывать различные сценарии, такие как успешное выполнение этапа или возникновение ошибки.


### OrchestratorResult

### OrchestratorResult

**Файл:** `src/app/llm/orchestrator.py`

**Описание:** Docstring:     """Результат полной обработки поста."""     post_id: str     overall_success: bool     stages: List[ProcessingStage]     final_data: Optional[Dict[str, Any]] = None     total_tokens: int = 0     t...; Has __init__ method

# Описание компонента OrchestratorResult

## 1. Назначение компонента
Компонент `OrchestratorResult` представляет собой структуру данных, которая хранит результаты полной обработки поста в системе ReAIboot. Он включает в себя информацию о статусе обработки, деталях каждого этапа и итоговых данных.

## 2. Основные методы/функции
В данном компоненте не определены методы, так как он является простым классом данных (data class), который используется для хранения информации. Однако, его атрибуты позволяют получить следующую информацию:
- `post_id`: идентификатор обрабатываемого поста.
- `overall_success`: общий статус успешности обработки.
- `stages`: список этапов обработки, каждый из которых представлен экземпляром класса `ProcessingStage`.
- `final_data`: итоговые данные после завершения всех этапов обработки (может быть `None`).
- `total_tokens`: общее количество токенов, использованных в процессе обработки.
- `total_time`: общее время, затраченное на обработку.
- `error`: информация об ошибках, если таковые имелись.

## 3. Зависимости и связи с другими компонентами
`OrchestratorResult` зависит от класса `ProcessingStage`, который представляет собой результат одного этапа обработки. Этот класс также является частью системы обработки постов, управляемой оркестратором. В свою очередь, `OrchestratorResult` используется в классе `LLMOrchestrator`, который координирует многоэтапную обработку постов, включая фильтрацию, анализ и генерацию данных.

## 4. Особенности реализации
- Класс реализован с использованием декоратора `@dataclass`, что упрощает создание экземпляров и управление атрибутами.
- Атрибуты класса имеют типизацию, что улучшает читаемость и поддержку кода.
- Некоторые атрибуты, такие как `final_data` и `error`, являются необязательными, что позволяет гибко обрабатывать различные сценарии обработки постов.


## 1. Назначение компонента
`OrchestratorResult` представляет собой класс, который хранит результаты полной обработки поста в системе ReAIboot. Он служит для агрегирования информации о статусе обработки, включая успех на каждом этапе, итоговые данные и возможные ошибки.

## 2. Основные методы/функции
Класс `OrchestratorResult` не содержит собственных методов, но его атрибуты позволяют хранить и передавать важную информацию:
- `post_id`: идентификатор обрабатываемого поста.
- `overall_success`: булевый флаг, указывающий на общий успех обработки.
- `stages`: список объектов типа `ProcessingStage`, представляющих результаты каждого этапа обработки.
- `final_data`: необязательный словарь с итоговыми данными обработки.
- `total_tokens`: общее количество использованных токенов.
- `total_time`: общее время, затраченное на обработку.
- `error`: необязательное поле для хранения информации об ошибках.

## 3. Зависимости и связи с другими компонентами
`OrchestratorResult` тесно связан с классом `ProcessingStage`, который описывает результаты отдельных этапов обработки. Он также используется в контексте класса `LLMOrchestrator`, который управляет многоэтапной обработкой постов, включая фильтрацию, анализ и генерацию. Таким образом, `OrchestratorResult` является частью системы, обеспечивающей комплексную обработку данных.

## 4. Особенности реализации
Класс реализован с использованием декоратора `@dataclass`, что упрощает создание и управление его экземплярами. Он не содержит методов, кроме автоматически сгенерированных методов для инициализации и представления данных. Это делает его легковесным и удобным для использования в качестве контейнера для результатов обработки.


### AnalysisProcessor

**Файл:** `src/app/llm/analysis_processor.py`

**Описание:** Docstring:     """Процессор для анализа постов с помощью Claude."""      def __init__(self):         """Инициализирует процессор анализа."""...; Has __init__ method

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### DocumentationAgent

**Файл:** `.cursorrules/update_docs.py`

**Описание:** Docstring:     """Main class for documentation updates"""      def __init__(self, project_root: str):         self.project_root = Path(project_root)         self.docs_root = self.project_root / "docs"         se...; Has __init__ method

**Назначение:** [Требуется описание]

**Методы:** [Требуется описание]

**Зависимости:** [Требуется анализ]


### HealthResponse

### HealthResponse

**Файл:** `src/api_main.py`

**Описание:** No additional info

# Описание компонента HealthResponse

## 1. Назначение компонента
Компонент `HealthResponse` в системе ReAIboot предназначен для обработки запросов, связанных с состоянием системы. Он может использоваться для проверки работоспособности API и предоставления информации о текущем состоянии сервисов, что важно для мониторинга и поддержания стабильности работы приложения.

## 2. Основные методы/функции
В предоставленной информации отсутствуют конкретные методы или функции, реализованные в классе `HealthResponse`. Однако, в контексте REST API, можно предположить, что класс может включать методы для:
- Проверки состояния системы (например, `/health` эндпоинт).
- Возврата статуса доступности сервисов.
- Предоставления информации о возможных ошибках или сбоях.

## 3. Зависимости и связи с другими компонентами
Класс `HealthResponse` может взаимодействовать с другими компонентами системы, такими как:
- `FastAPI`: для обработки HTTP-запросов и ответов.
- Логирование: для записи состояния системы и возможных ошибок.
- Другие сервисы в рамках ReAIboot, такие как `LLMOrchestrator`, `TelegramAnalyzer` и `SupabaseManager`, для получения информации о состоянии их работы.

## 4. Особенности реализации
В предоставленном контексте нет конкретных деталей реализации класса `HealthResponse`. Однако, учитывая использование FastAPI, можно ожидать, что реализация будет следовать принципам асинхронного программирования и включать обработку ошибок с использованием исключений, таких как `HTTPException`. Также возможно использование моделей данных для структурирования ответов о состоянии системы.

Таким образом, класс `HealthResponse` является важной частью системы, обеспечивающей мониторинг и поддержку работоспособности API ReAIboot.


### LLMOrchestrator

### LLMOrchestrator

**Файл:** `src/app/llm/orchestrator.py`

**Описание:** Docstring:     """Оркестратор для управления многоэтапной обработкой постов."""      def __init__(self):         """Инициализирует оркестратор."""...; Has __init__ method

# Описание компонента LLMOrchestrator

## 1. Назначение компонента
Компонент `LLMOrchestrator` предназначен для управления многоэтапной обработкой постов в системе ReAIboot. Он координирует три ключевых этапа обработки: фильтрацию, анализ и генерацию, обеспечивая последовательное выполнение задач и управление результатами на каждом этапе.

## 2. Основные методы/функции
- **`__init__`**: Инициализирует оркестратор и создает экземпляры процессоров для фильтрации, анализа, выбора рубрики и генерации. Также проверяет доступность этих процессоров.
- **Обработка постов**: Хотя в предоставленном контексте не указаны конкретные методы для обработки постов, можно предположить, что оркестратор будет иметь методы для запуска каждого этапа обработки и сбора результатов.

## 3. Зависимости и связи с другими компонентами
`LLMOrchestrator` зависит от нескольких других компонентов:
- **`FilterProcessor`**: Отвечает за фильтрацию входных данных.
- **`AnalysisProcessor`**: Проводит анализ отфильтрованных данных.
- **`RubricSelectorProcessor`**: Выбирает рубрики для дальнейшей обработки.
- **`GeneratorProcessor`**: Генерирует финальные результаты на основе анализа.
- **`setup_logger`**: Используется для настройки логирования, что позволяет отслеживать работу оркестратора.
- **`settings`, `price_monitor`, `supabase_client`, `prompt_manager`**: Эти модули могут использоваться для настройки, мониторинга цен, работы с базой данных и управления подсказками, хотя их конкретные роли не описаны в предоставленном контексте.

## 4. Особенности реализации
- Компонент использует асинхронное программирование (импорт `asyncio`), что позволяет эффективно обрабатывать задачи без блокировки.
- Результаты каждого этапа обработки представлены в виде объектов `ProcessingStage`, что упрощает отслеживание успеха, ошибок и использования токенов.
- Итоговые результаты обработки поста объединяются в объект `OrchestratorResult`, который содержит информацию о всех этапах, общем успехе и времени обработки.
- Логирование настроено для


## 1. Назначение компонента
Компонент `LLMOrchestrator` предназначен для управления многоэтапной обработкой постов в системе ReAIboot. Он координирует три основных этапа обработки: фильтрацию, анализ и генерацию контента.

## 2. Основные методы/функции
- **`__init__`**: Инициализирует оркестратор и создает экземпляры процессоров для каждого этапа обработки (фильтрация, анализ, выбор рубрики и генерация).
- **Проверка доступности процессоров**: В конструкторе происходит проверка доступности каждого из процессоров, что позволяет убедиться в их работоспособности перед началом обработки.

## 3. Зависимости и связи с другими компонентами
`LLMOrchestrator` зависит от следующих компонентов:
- **FilterProcessor**: отвечает за фильтрацию входных данных.
- **AnalysisProcessor**: выполняет анализ отфильтрованных данных.
- **RubricSelectorProcessor**: выбирает соответствующую рубрику для поста.
- **GeneratorProcessor**: генерирует финальный контент на основе анализа и выбранной рубрики.

Кроме того, компонент использует утилиты для логирования и настройки, а также взаимодействует с клиентом Supabase для хранения и получения данных.

## 4. Особенности реализации
- Использование `dataclass` для определения структур данных, таких как `ProcessingStage` и `OrchestratorResult`, что упрощает управление состоянием и результатами обработки.
- Логирование для отслеживания работы оркестратора и выявления возможных ошибок на каждом этапе обработки.
- Асинхронная обработка, что позволяет улучшить производительность и отзывчивость системы при выполнении многоэтапных задач.

Таким образом, `LLMOrchestrator` является ключевым компонентом системы, обеспечивающим эффективное управление процессами обработки постов.


## Функции

### main

### main

**Файл:** `src/app/cli.py`

**Описание:** Docstring:     """Точка входа для запуска как самостоятельного модуля."""     cli = CLI()     args = cli.parse_args()     print("Аргументы:", vars(args))     print("Для запуска используйте: python -m src.main") ...

# Описание компонента `main` системы ReAIboot

## 1. Назначение компонента
Компонент `main` является точкой входа для запуска системы ReAIboot как самостоятельного модуля. Он предназначен для обработки аргументов командной строки, которые позволяют пользователю настраивать параметры анализа Telegram-каналов и генерации идей для контента.

## 2. Основные методы/функции
- **`__init__`**: Инициализирует объект класса `CLI`, который отвечает за обработку аргументов командной строки.
- **`parse_args`**: Метод класса `CLI`, который парсит аргументы командной строки, предоставляя пользователю возможность задавать различные параметры анализа, такие как количество дней для анализа, количество лучших постов и пути к файлам конфигурации.

## 3. Зависимости и связи с другими компонентами
Компонент `main` зависит от класса `CLI`, который реализован в модуле `src/app/cli.py`. Класс `CLI` использует библиотеку `argparse` для обработки аргументов командной строки и библиотеку `logging` для ведения логов. Также он взаимодействует с настройками, определенными в модуле `settings`, и утилитами из модуля `utils`, такими как `setup_logger`.

## 4. Особенности реализации
- Компонент использует библиотеку `argparse` для создания удобного интерфейса командной строки, что позволяет пользователю легко настраивать параметры анализа.
- Логирование настроено через вспомогательную функцию `setup_logger`, что обеспечивает отслеживание событий и ошибок в процессе выполнения.
- Компонент поддерживает несколько параметров, таких как количество дней для анализа, количество лучших постов и пути к файлам, что делает его гибким и настраиваемым под различные сценарии использования.


## 1. Назначение компонента
Компонент `main` является точкой входа в приложение ReAIboot. Он отвечает за инициализацию и запуск основного процесса анализа данных, взаимодействуя с пользовательским интерфейсом командной строки (CLI).

## 2. Основные методы/функции
- **run_analysis(args: argparse.Namespace)**: Основная асинхронная функция, которая выполняет анализ данных на основе аргументов, переданных из командной строки. Она включает в себя:
  - Загрузку списка каналов для анализа.
  - Настройку параметров анализа, таких как количество дней, количество сообщений и использование LLM (Large Language Model).
  - Сбор данных из указанных каналов.

## 3. Зависимости и связи с другими компонентами
Компонент `main` зависит от нескольких других модулей системы:
- **CLI**: Обрабатывает аргументы командной строки.
- **MessageFetcher**: Отвечает за сбор данных из каналов.
- **Settings**: Загружает конфигурации, такие как список каналов и веса для расчета метрик.
- **TelegramAnalyzer**, **MetricsCalculator**, **ContentMapper**, **LLMProcessor**, **DataWriter**, **SmartTopPostsFilter**, **SupabaseManager**: Эти модули могут быть использованы в процессе анализа для различных задач, таких как обработка сообщений, вычисление метрик и запись данных.

## 4. Особенности реализации
- Используется асинхронное программирование с библиотекой `asyncio`, что позволяет эффективно обрабатывать запросы и собирать данные.
- Логирование настроено с помощью функции `setup_logger`, что обеспечивает отслеживание процесса выполнения и отладку.
- Включена поддержка библиотеки `tqdm` для отображения индикаторов прогресса, что улучшает пользовательский опыт при выполнении длительных операций.
- Обработка ошибок осуществляется с помощью конструкции `try-except`, что позволяет избежать сбоев в работе приложения при возникновении исключений.

Таким образом, компонент `main` играет ключевую роль в запуске и управлении процессом анализа данных в системе ReAIboot.


## Взаимодействие компонентов

Диаграмма взаимодействия основных компонентов:

```
Frontend (Next.js) <-> API (FastAPI) <-> LLM Services <-> Database (Supabase)
```

## Поток данных

1. Пользователь отправляет запрос через UI
2. API получает запрос и валидирует данные
3. Данные передаются в LLM процессоры
4. Результат сохраняется в базу данных
5. Ответ возвращается пользователю
